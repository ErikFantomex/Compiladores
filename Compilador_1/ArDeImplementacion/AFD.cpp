/* Nombre: .cpp
   Autor:
   Fecha:
   Descripción:
*/
#include"../AFD.h"


 /*****************************************************************************************
 **********************************   Constructores    ************************************
 *****************************************************************************************/

//*************************************************************************************
AFD::AFD(): nEstados(0), matTrans(NULL), eAcept(NULL)
{

}

//*************************************************************************************
AFD::AFD(const AFD & afd2): nEstados(0), matTrans(NULL), eAcept(NULL)
{
    *this = afd2;
}

//*************************************************************************************
AFD::AFD(const int &n, const int &m)
{
    Dimencionar(n,m);
}

//*************************************************************************************
AFD::~AFD()
{
    Vaciar();
}


 /*****************************************************************************************
 ************************************    Operadores    ************************************
 *****************************************************************************************/
//*************************************************************************************
AFD & AFD::operator= (const AFD & afd2)
{
    if(this == &afd2) return *this;

    Vaciar();
    Dimencionar(afd2.nEstados,afd2.tamAlf,0);

    for(int i=0;i < nEstados; ++i)
    {
        eAcept[i]= afd2.eAcept[i];
        for(int j=0; j<tamAlf; ++j)
            (*this)[i][j] = afd2[i][j];
    }


    estActl =afd2.estActl;
    return *this;
}

//*************************************************************************************
int* AFD::operator[] (const int & i)
{
    return matTrans[i];
}

//*************************************************************************************
const int * AFD::operator[] (const int & i) const
{
    return matTrans[i];
}


 /*****************************************************************************************
 ********************************   Metodos y funciónes   *********************************
 *****************************************************************************************/
//*************************************************************************************
void AFD::Imprimir(std::ostream & salida/*=std::cout*/)const
{
    int c=0;
    for(int j=0; j <tamAlf; ++j)
    {
        if( (*this)[0][j] != -1)
        {
            salida<<(char)(j+128)<<" ";
        }
    }
    salida<<'\n';

    for(int i=0;i<nEstados;++i)
    {
        int c=0;
        for(int j=0; j <tamAlf; ++j)
        {
            if( (*this)[i][j] != -1)
            {
                c++;
                if( (*this)[i][j] == 139)
                    salida<<0<<' ';
                else
                    salida<<matTrans[i][j]<<' ';
            }
        }
        salida<<c;
        salida<<'\n';
    }
}

//*************************************************************************************
void AFD::Reset()
{
    estActl=0;
}

//*************************************************************************************
void AFD::SetEstadosA(const int &i , const bool &e)
{
    eAcept[i] = e;
}

//*************************************************************************************
void AFD::Avanzar(const int &c)
{
    estActl = matTrans[estActl][c];
}

//*************************************************************************************
bool AFD::estadoAceptacion() const
{
    return eAcept[estActl];
}

//*************************************************************************************
void AFD::Dimencionar(const int &n, const int &m, const int &valIn/*=-1*/)
{
    matTrans = new int*[n];
    for(int i=0;i<n;++i)
        matTrans[i] = new int[m];
    eAcept= new bool[n];

    nEstados = n;
    tamAlf=m;
    estActl=0;

    for(int i=0;i<n;++i)
    {
        eAcept[i]=false;
        for(int j=0; j <m; ++j)
            matTrans[i][j]=valIn;
    }
}


//*************************************************************************************
void AFD::Vaciar()
{

    for(int i=0;i<nEstados;++i)
        delete [] matTrans[i];
    delete [] matTrans;
    delete [] eAcept;

    nEstados = 0;
    matTrans= NULL;
    eAcept=NULL;
}

//*************************************************************************************
const int & AFD::GetNEstados() const
{
    return nEstados;
}

//*************************************************************************************
const int & AFD::GetEstadoAct() const
{
    return estActl;
}

//*************************************************************************************
const int & AFD::GetTamAlfabeto() const
{
    return tamAlf;
}


 /*****************************************************************************************
 ************************************   Excepciónes   *************************************
 *****************************************************************************************/
//*************************************************************************************
const char * AFD::CaracterFuera::what() const throw()
{
    return "Se introdujo un caracter fuera del alfabeto...";
}

//*************************************************************************************
const char * AFD::EstadoInexistente::what() const throw()
{
    return "El estado est\240 no existe...";
}

 /*****************************************************************************************
 *********************************   Metodos privados   ***********************************
 *****************************************************************************************/

 /*****************************************************************************************
 ***************************   Funciones externas y amigas   ******************************
 *****************************************************************************************/
std::ostream & operator<<(std::ostream & salida,const AFD & afd)
{
    afd.Imprimir();
    return salida;
}
