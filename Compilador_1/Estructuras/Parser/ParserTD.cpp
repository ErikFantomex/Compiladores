/* Nombre: .cpp
   Autor:
   Fecha:
   Descripción:
*/
#include"ParserTD.h"


 /*****************************************************************************************
 **********************************   Constructores    ************************************
 *****************************************************************************************/

//*************************************************************************************
ParserTD::ParserTD(const char *dir)
{
    gram.InicializarGram(dir);
}


 /*****************************************************************************************
 ************************************    Operadores    ************************************
 *****************************************************************************************/

 /*****************************************************************************************
 ********************************   Metodos y funciónes   *********************************
 *****************************************************************************************/
//*************************************************************************************
bool ParserTD::EvaluarCadena(std::string * cadena, int tamCad)
{
    int tamProd;
    std::string *prodAux;
    std::string tAux;

    //Regla 1
    TOS.Vaciar();
    TOS.Apilar("E");

    int i=0;
    try {

        while(!TOS.EstaVacia())
        {
            tAux = TOS.ObtenerTope();

            //Regla 3
            if(tAux == gram.NormalizarT(cadena[i]))
            {
                ++i;
                TOS.Desapilar();
                continue;
            }
            else
            {
                if(tAux[0] == 'T') //Regla 4
                    return false;
                else
                {
                    //Regla 5
                    if(i != tamCad) //Si'i' es igual al tamaño, se evalua con '$'
                        prodAux = gram.GetProduccion(tAux,cadena[i],tamProd);
                    else
                        prodAux = gram.GetProduccion(tAux,FINCADENA,tamProd);

                    //Regla 5_1
                    //Si la produccion está vacia, se regresa false
                    if(prodAux[0] == P_ERRONEA) return false;

                    //Regla 5_2
                    TOS.Desapilar();
                    for( ; tamProd > 0;--tamProd)
                    {
                        if(prodAux[tamProd-1] != EPSILON)
                            TOS.Apilar(prodAux[tamProd-1]);
                    }
                }
            }

        }
    }
    catch(...){
        return false;
    }

    //Regla 2
    return i == tamCad;
}



 /*****************************************************************************************
 ************************************   Excepciónes   *************************************
 *****************************************************************************************/
//*************************************************************************************
const char * ParserTD::CaracterFuera::what() const throw()
{
    return "Se introdujo un caracter fuera del alfabeto...";
}

 /*****************************************************************************************
 *********************************   Metodos privados   ***********************************
 *****************************************************************************************/

 /*****************************************************************************************
 ***************************   Funciones externas y amigas   ******************************
 *****************************************************************************************/
